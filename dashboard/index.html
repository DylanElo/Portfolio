<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Pierrot BI Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }

        .glass {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
    </style>
</head>

<body class="min-h-screen p-6">

    <!-- Loading Screen -->
    <div id="loadingScreen" class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900 text-white">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-purple-500 mb-4 mx-auto"></div>
            <h2 class="text-2xl font-bold">Loading Analytics...</h2>
            <p class="text-gray-400 mt-2">Fetching latest studio data</p>
        </div>
    </div>

    <div id="dashboardContent" style="display: none;">
        <!-- Header & Filters -->
        <div class="flex flex-col lg:flex-row gap-6 mb-8">
            <div class="glass p-6 lg:w-64 flex-shrink-0 h-fit">
                <h1
                    class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 mb-6">
                    Studio Pierrot BI
                </h1>

                <div class="mb-4">
                    <label class="block text-sm mb-2 text-gray-300">Time Range</label>
                    <select id="dateFilter"
                        class="w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 outline-none">
                        <option value="all">All Time</option>
                        <option value="2023-01">January 2023</option>
                        <option value="2023-02">February 2023</option>
                        <option value="2023-03">March 2023</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label class="block text-sm mb-2 text-gray-300">Franchise / Anime</label>
                    <select id="animeFilter"
                        class="w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 outline-none">
                        <option value="all">All Franchises</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label class="block text-sm mb-2 text-gray-300">Platform</label>
                    <div id="platformFilters" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>

                <button id="resetFilters"
                    class="w-full bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-semibold py-2.5 px-4 rounded-lg transition mt-4 shadow-lg">
                    Reset Filters
                </button>
            </div>

            <!-- Main Content -->
            <div class="flex-1">
                <div class="mb-8 fade-in">
                    <h2 class="text-4xl font-bold text-white mb-2">Executive Dashboard</h2>
                    <p class="text-purple-200">Strategic insights to optimize production ROI</p>
                </div>

                <!-- KPIs -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8 fade-in" id="kpiContainer">
                    <!-- KPIs inserted via JS -->
                </div>

                <!-- Row 1: Trend & Platform -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div class="glass lg:col-span-2 p-6 fade-in">
                        <h3 class="text-xl font-semibold text-gray-100 mb-4">üìà Revenue & Views Trend</h3>
                        <div class="chart-container">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>
                    <div class="glass p-6 fade-in">
                        <h3 class="text-xl font-semibold text-gray-100 mb-4">üéØ Platform Distribution</h3>
                        <div class="chart-container">
                            <canvas id="platformChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Row 2: Scatter & Heatmap -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div class="glass lg:col-span-2 p-6 fade-in">
                        <h3 class="text-xl font-semibold text-gray-100 mb-1">üíé The "Filler Trap": ROI vs Filler %</h3>
                        <p class="text-sm text-gray-400 mb-4">Higher filler content correlates with lower ROI. Bubble
                            size = Total Views.</p>
                        <div class="chart-container">
                            <canvas id="scatterChart"></canvas>
                        </div>
                    </div>
                    <div class="glass p-6 fade-in">
                        <h3 class="text-xl font-semibold text-gray-100 mb-4">üìÖ Weekly Engagement</h3>
                        <div class="chart-container">
                            <canvas id="heatmapChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Row 3: Completion Rate (New) -->
                <div class="glass p-6 mb-8 fade-in">
                    <h3 class="text-xl font-semibold text-gray-100 mb-4">üì∫ Viewer Retention (Completion Rate)</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="completionChart"></canvas>
                    </div>
                </div>

                <!-- Table -->
                <div class="glass p-6 fade-in">
                    <h3 class="text-xl font-semibold text-gray-100 mb-4">üèÜ Top Anime Performance</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full text-left">
                            <thead class="bg-slate-800 text-gray-300">
                                <tr>
                                    <th class="px-6 py-4 text-xs font-semibold uppercase tracking-wider rounded-tl-lg">
                                        Title</th>
                                    <th class="px-6 py-4 text-right text-xs font-semibold uppercase tracking-wider">
                                        Revenue</th>
                                    <th class="px-6 py-4 text-right text-xs font-semibold uppercase tracking-wider">
                                        Views</th>
                                    <th class="px-6 py-4 text-center text-xs font-semibold uppercase tracking-wider">
                                        Sentiment (0-1)</th>
                                    <th
                                        class="px-6 py-4 text-center text-xs font-semibold uppercase tracking-wider rounded-tr-lg">
                                        ROI</th>
                                </tr>
                            </thead>
                            <tbody id="animeTableBody" class="divide-y divide-slate-700 text-gray-300">
                                <!-- Rows inserted via JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let rawData = null;
        let charts = {};

        // --- Data Loading & Preprocessing ---
        fetch('data.json')
            .then(res => {
                if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to load data`);
                return res.json();
            })
            .then(data => {
                console.log('Data loaded:', data);
                data = aggregateFranchises(data);
                rawData = data;

                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';

                initDashboard(data);
            })
            .catch(err => {
                console.error('Error:', err);
                document.getElementById('loadingScreen').innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                        <div class="text-2xl font-bold mb-2">Error Loading Dashboard</div>
                        <div class="text-lg">${err.message}</div>
                    </div>
                `;
            });

        function aggregateFranchises(data) {
            const franchiseMap = {
                'Naruto Franchise': ['Naruto', 'Naruto: Shippuuden'],
                'Bleach Franchise': ['Bleach', 'Bleach: Sennen Kessen-hen']
            };

            // 1. Aggregate Daily Trend
            if (data.daily_anime_trend) {
                const agg = {};
                data.daily_anime_trend.forEach(entry => {
                    let title = entry.title;
                    for (const [franchise, titles] of Object.entries(franchiseMap)) {
                        if (titles.includes(title)) { title = franchise; break; }
                    }
                    const key = `${entry.date}_${title}`;
                    if (!agg[key]) agg[key] = { date: entry.date, title, views: 0, revenue: 0 };
                    agg[key].views += (entry.views || 0);
                    agg[key].revenue += (entry.revenue || 0);
                });
                data.daily_anime_trend = Object.values(agg);
            }

            // 2. Aggregate Scatter Plot (ROI & Filler)
            // We need this FIRST to merge ROI into anime_performance
            const scatterAgg = {};
            if (data.scatter_plot) {
                data.scatter_plot.forEach(item => {
                    let title = item.title;
                    for (const [franchise, titles] of Object.entries(franchiseMap)) {
                        if (titles.includes(title)) { title = franchise; break; }
                    }
                    if (!scatterAgg[title]) {
                        scatterAgg[title] = {
                            title,
                            filler_percentage: 0,
                            roi_percentage: 0,
                            total_views: 0,
                            count: 0
                        };
                    }
                    scatterAgg[title].filler_percentage += item.filler_percentage;
                    scatterAgg[title].roi_percentage += item.roi_percentage;
                    scatterAgg[title].total_views += item.total_views;
                    scatterAgg[title].count++;
                });

                data.scatter_plot = Object.values(scatterAgg).map(item => ({
                    title: item.title,
                    filler_percentage: item.filler_percentage / item.count,
                    roi_percentage: item.roi_percentage / item.count,
                    total_views: item.total_views
                }));
            }

            // 3. Aggregate Anime Performance (Table Data)
            if (data.anime_performance) {
                const agg = {};
                data.anime_performance.forEach(anime => {
                    let title = anime.title;
                    for (const [franchise, titles] of Object.entries(franchiseMap)) {
                        if (titles.includes(title)) { title = franchise; break; }
                    }
                    if (!agg[title]) {
                        agg[title] = {
                            title,
                            views: 0,
                            revenue: 0,
                            sentiment: 0,
                            completion_rate: 0,
                            count: 0
                        };
                    }
                    agg[title].views += (anime.views || 0);
                    agg[title].revenue += (anime.revenue || 0);
                    agg[title].sentiment += (anime.sentiment || anime.avg_sentiment || 0);
                    agg[title].completion_rate += (anime.completion_rate || 0);
                    agg[title].count++;
                });

                data.anime_performance = Object.values(agg).map(anime => {
                    // Find ROI from scatter data
                    const scatterItem = data.scatter_plot.find(s => s.title === anime.title);
                    const roi = scatterItem ? scatterItem.roi_percentage : 0;

                    return {
                        ...anime,
                        sentiment: anime.sentiment / anime.count,
                        completion_rate: anime.completion_rate / anime.count,
                        roi: roi
                    };
                });
            }

            // 4. Update Anime List
            if (data.anime_list) {
                const uniqueTitles = new Set();
                data.anime_list.forEach(anime => {
                    let title = anime.title || anime;
                    for (const [franchise, titles] of Object.entries(franchiseMap)) {
                        if (titles.includes(title)) { title = franchise; break; }
                    }
                    uniqueTitles.add(title);
                });
                data.anime_list = Array.from(uniqueTitles).map(title => ({ title }));
            }

            return data;
        }

        // --- Initialization ---
        function initDashboard(data) {
            // Populate Anime Filter
            const animeFilter = document.getElementById('animeFilter');
            if (data.anime_list) {
                data.anime_list.forEach(a => {
                    const opt = document.createElement('option');
                    opt.value = a.title;
                    opt.textContent = a.title;
                    animeFilter.appendChild(opt);
                });
            }

            // Populate Platform Filter
            const platformContainer = document.getElementById('platformFilters');
            if (data.platform_split) {
                data.platform_split.forEach(p => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 text-sm text-gray-300 cursor-pointer hover:text-white';
                    const name = p.platform_name || p.name || 'Unknown';
                    label.innerHTML = `
                        <input type="checkbox" checked value="${name}" class="platform-checkbox rounded text-purple-600 focus:ring-purple-500 bg-slate-700 border-slate-500">
                        <span>${name}</span>
                    `;
                    platformContainer.appendChild(label);
                });
            }

            // Event Listeners
            document.getElementById('dateFilter').addEventListener('change', applyFilters);
            document.getElementById('animeFilter').addEventListener('change', applyFilters);
            document.querySelectorAll('.platform-checkbox').forEach(cb => cb.addEventListener('change', applyFilters));
            document.getElementById('resetFilters').addEventListener('click', resetFilters);

            renderDashboard(data);
        }

        function resetFilters() {
            document.getElementById('dateFilter').value = 'all';
            document.getElementById('animeFilter').value = 'all';
            document.querySelectorAll('.platform-checkbox').forEach(cb => cb.checked = true);
            applyFilters();
        }

        function applyFilters() {
            const dateFilter = document.getElementById('dateFilter').value;
            const animeFilter = document.getElementById('animeFilter').value;
            const selectedPlatforms = Array.from(document.querySelectorAll('.platform-checkbox:checked')).map(cb => cb.value);

            // Filter Daily Trend
            let filteredTrend = rawData.daily_anime_trend || [];
            if (dateFilter !== 'all') {
                filteredTrend = filteredTrend.filter(d => d.date && d.date.startsWith(dateFilter));
            }
            if (animeFilter !== 'all') {
                filteredTrend = filteredTrend.filter(d => d.title === animeFilter);
            }

            // Re-aggregate Trend for Chart
            const trendMap = {};
            filteredTrend.forEach(d => {
                if (!trendMap[d.date]) trendMap[d.date] = { date: d.date, views: 0, revenue: 0 };
                trendMap[d.date].views += d.views;
                trendMap[d.date].revenue += d.revenue;
            });
            const aggregatedTrend = Object.values(trendMap).sort((a, b) => new Date(a.date) - new Date(b.date));

            // Filter Platforms
            const filteredPlatforms = (rawData.platform_split || []).filter(p => selectedPlatforms.includes(p.platform_name || p.name));

            // Filter Anime Performance
            let filteredAnime = rawData.anime_performance || [];
            if (animeFilter !== 'all') {
                filteredAnime = filteredAnime.filter(a => a.title === animeFilter);
            }

            // Filter Scatter Plot (Highlighting logic or filtering)
            // For scatter, if an anime is selected, we could filter to just that one, but usually scatter is for comparison.
            // Let's filter it to show only selected anime if filter is active, otherwise show all.
            let filteredScatter = rawData.scatter_plot || [];
            if (animeFilter !== 'all') {
                filteredScatter = filteredScatter.filter(d => d.title === animeFilter);
            }

            // Update All Charts
            updateTrendChart(aggregatedTrend);
            updatePlatformChart(filteredPlatforms);
            updateScatterChart(filteredScatter);
            updateAnimeTable(filteredAnime);
            updateCompletionChart(filteredAnime);
            // Heatmap usually static or complex to filter by date daily, but let's leave it static for now or filter by anime
            // If we filter heatmap by anime:
            // (Heatmap data in data.json is usually pre-aggregated by day of week. If we have daily_anime_trend, we can re-aggregate)
            // For simplicity, we'll leave heatmap static as "Global Engagement" unless we want to re-calc from daily_trend.
        }

        function renderDashboard(data) {
            renderKPIs(data.kpis || {});
            renderTrendChart(data.daily_trend || []); // Initial view
            renderPlatformChart(data.platform_split || []);
            renderScatterChart(data.scatter_plot || []);
            renderHeatmap(data.heatmap || []);
            renderCompletionChart(data.anime_performance || []);
            updateAnimeTable(data.anime_performance || []);
        }

        // --- Render Functions ---

        function renderKPIs(kpis) {
            const container = document.getElementById('kpiContainer');
            const items = [
                { label: 'Total Revenue', value: kpis.total_revenue, fmt: 'currency', icon: 'üí∞', color: 'border-purple-500' },
                { label: 'Total Views', value: kpis.total_views, fmt: 'number', icon: 'üëÅÔ∏è', color: 'border-blue-500' },
                { label: 'Watch Time (Hrs)', value: (kpis.total_watch_time || 0) / 60, fmt: 'number', icon: '‚è±Ô∏è', color: 'border-pink-500' },
                { label: 'Avg Sentiment', value: kpis.avg_sentiment, fmt: 'decimal', icon: 'üòä', color: 'border-green-500' }
            ];

            container.innerHTML = items.map(item => `
                <div class="glass p-6 border-l-4 ${item.color}">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-gray-400 text-sm font-medium">${item.label}</span>
                        <span class="text-2xl">${item.icon}</span>
                    </div>
                    <div class="text-3xl font-bold text-white">
                        ${formatValue(item.value, item.fmt)}
                    </div>
                </div>
            `).join('');
        }

        function renderTrendChart(data) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            charts.trend = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.date),
                    datasets: [
                        {
                            label: 'Revenue ($)',
                            data: data.map(d => d.revenue),
                            borderColor: '#a855f7', // Purple-500
                            backgroundColor: 'rgba(168, 85, 247, 0.1)',
                            yAxisID: 'y',
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Views',
                            data: data.map(d => d.views),
                            borderColor: '#3b82f6', // Blue-500
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            yAxisID: 'y1',
                            fill: true,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { labels: { color: '#cbd5e1' } } },
                    scales: {
                        x: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y: { position: 'left', grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y1: { position: 'right', grid: { display: false }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        function updateTrendChart(data) {
            if (!charts.trend) return;
            charts.trend.data.labels = data.map(d => d.date);
            charts.trend.data.datasets[0].data = data.map(d => d.revenue);
            charts.trend.data.datasets[1].data = data.map(d => d.views);
            charts.trend.update();
        }

        function renderPlatformChart(data) {
            const ctx = document.getElementById('platformChart').getContext('2d');
            charts.platform = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: data.map(d => d.platform_name || d.name),
                    datasets: [{
                        data: data.map(d => d.revenue || d.value),
                        backgroundColor: ['#a855f7', '#3b82f6', '#ec4899', '#10b981', '#f59e0b'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { color: '#cbd5e1' } },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const val = context.raw;
                                    const total = context.chart._metasets[context.datasetIndex].total;
                                    const pct = ((val / total) * 100).toFixed(1) + '%';
                                    return `${context.label}: ${formatValue(val, 'currency')} (${pct})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updatePlatformChart(data) {
            if (!charts.platform) return;
            charts.platform.data.labels = data.map(d => d.platform_name || d.name);
            charts.platform.data.datasets[0].data = data.map(d => d.revenue || d.value);
            charts.platform.update();
        }

        function renderScatterChart(data) {
            const ctx = document.getElementById('scatterChart').getContext('2d');
            const scatterData = data.map(d => ({
                x: d.filler_percentage,
                y: d.roi_percentage,
                r: Math.sqrt(d.total_views) / 2000, // Bubble size
                anime: d.title
            }));

            charts.scatter = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Franchises',
                        data: scatterData,
                        backgroundColor: 'rgba(236, 72, 153, 0.6)', // Pink-500
                        borderColor: '#ec4899',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: ctx => `${ctx.raw.anime}: ROI ${ctx.raw.y.toFixed(1)}%, Filler ${ctx.raw.x}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Filler Percentage (%)', color: '#94a3b8' },
                            grid: { color: '#334155' }, ticks: { color: '#94a3b8' }
                        },
                        y: {
                            title: { display: true, text: 'ROI Percentage (%)', color: '#94a3b8' },
                            grid: { color: '#334155' }, ticks: { color: '#94a3b8' }
                        }
                    }
                }
            });
        }

        function updateScatterChart(data) {
            if (!charts.scatter) return;
            charts.scatter.data.datasets[0].data = data.map(d => ({
                x: d.filler_percentage,
                y: d.roi_percentage,
                r: Math.sqrt(d.total_views) / 2000,
                anime: d.title
            }));
            charts.scatter.update();
        }

        function renderHeatmap(data) {
            const ctx = document.getElementById('heatmapChart').getContext('2d');
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const sorted = [...data].sort((a, b) => days.indexOf(a.day_name) - days.indexOf(b.day_name));

            charts.heatmap = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(d => d.day_name),
                    datasets: [{
                        label: 'Avg Views',
                        data: sorted.map(d => d.views),
                        backgroundColor: '#10b981', // Emerald-500
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        function renderCompletionChart(data) {
            const ctx = document.getElementById('completionChart').getContext('2d');
            // Sort by completion rate desc
            const sorted = [...data].sort((a, b) => b.completion_rate - a.completion_rate);

            charts.completion = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(d => d.title),
                    datasets: [{
                        label: 'Completion Rate',
                        data: sorted.map(d => d.completion_rate * 100), // Convert to %
                        backgroundColor: '#f59e0b', // Amber-500
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Horizontal bar
                    plugins: { legend: { display: false } },
                    scales: {
                        x: {
                            max: 100,
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8', callback: v => v + '%' }
                        },
                        y: { grid: { display: false }, ticks: { color: '#94a3b8' } }
                    }
                }
            });
        }

        function updateCompletionChart(data) {
            if (!charts.completion) return;
            const sorted = [...data].sort((a, b) => b.completion_rate - a.completion_rate);
            charts.completion.data.labels = sorted.map(d => d.title);
            charts.completion.data.datasets[0].data = sorted.map(d => d.completion_rate * 100);
            charts.completion.update();
        }

        function updateAnimeTable(data) {
            const tbody = document.getElementById('animeTableBody');
            if (!data.length) {
                tbody.innerHTML = '<tr><td colspan="5" class="p-4 text-center text-gray-500">No data found</td></tr>';
                return;
            }

            // Sort by Revenue Desc
            const sorted = [...data].sort((a, b) => b.revenue - a.revenue);

            tbody.innerHTML = sorted.map(anime => {
                const sentiment = anime.sentiment;
                const sentimentColor = sentiment >= 0.7 ? 'text-green-400' : (sentiment >= 0.5 ? 'text-yellow-400' : 'text-red-400');
                const roi = anime.roi;
                const roiColor = roi >= 0 ? 'text-green-400' : 'text-red-400'; // ROI % can be negative

                return `
                    <tr class="hover:bg-slate-800/50 transition-colors border-b border-slate-700 last:border-0">
                        <td class="px-6 py-4 font-medium text-white">${anime.title}</td>
                        <td class="px-6 py-4 text-right text-gray-300">${formatValue(anime.revenue, 'currency')}</td>
                        <td class="px-6 py-4 text-right text-gray-300">${formatValue(anime.views, 'number')}</td>
                        <td class="px-6 py-4 text-center ${sentimentColor}">${sentiment.toFixed(2)}</td>
                        <td class="px-6 py-4 text-center ${roiColor}">${roi.toFixed(1)}%</td>
                    </tr>
                `;
            }).join('');
        }

        // --- Helpers ---
        function formatValue(val, type) {
            if (val === null || val === undefined) return '-';
            if (type === 'currency') {
                if (val >= 1e6) return '$' + (val / 1e6).toFixed(1) + 'M';
                if (val >= 1e3) return '$' + (val / 1e3).toFixed(1) + 'K';
                return '$' + val.toFixed(0);
            }
            if (type === 'number') {
                if (val >= 1e6) return (val / 1e6).toFixed(1) + 'M';
                if (val >= 1e3) return (val / 1e3).toFixed(1) + 'K';
                return val.toLocaleString();
            }
            if (type === 'decimal') return val.toFixed(2);
            return val;
        }
    </script>
</body>

</html>